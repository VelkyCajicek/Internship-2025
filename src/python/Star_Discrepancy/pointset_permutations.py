import random
import copy
from collections import Counter
from python.Transformations.Bundschuh_Zhu import Bundschuh_Zhu_Algorithm_TP2

def show_pointset(pointset : list) -> None:
    for i in range(len(pointset)):
        print(f"{pointset[i]}")

class RandomPointset:
    def __init__(self, pointset_length : int = 10, repeating_probability : float = 0.3, decimal_places : int = 1, number_of_permutations : int = 3):
        self.pointset_length = pointset_length
        # Repeating probability should be between 0 and 1
        self.repeating_probability = repeating_probability 
        self.decimal_places = decimal_places 
        self.number_of_permutations = number_of_permutations
        self.pointset = self.generate_pointset()
    
    def generate_pointset(self) -> list:
        # Code in this is ugly as shit but it works
        points_x = []
        points_y = []
        
        for i in range(self.pointset_length):
            # Uniform instead of randint since it returns floats instead of ints
            x = round(random.uniform(0,1), self.decimal_places)
            y = round(random.uniform(0,1), self.decimal_places)
            
            # Chooses a random value between 1,100 (1% - 100%) and checks whether its larger than the probability * 100
            if(random.randint(1,100) <= int(self.repeating_probability*100) and i != 0):
                # random.choice() selects a element at random
                if(random.choice([True, False])):
                    x = random.choice(points_x)
                else:
                    y = random.choice(points_y)

            points_x.append(x)
            points_y.append(y)

        return sorted([list(coordinate) for coordinate in zip(points_x, points_y)], key=lambda coord : coord[0])

    def permute_original_pointset(self):
        # Function generated by ChatGPT that just works
        permutations = []
        # Process the sorted pointset in one pass
        i = 0
        while i < self.pointset_length:
            x_val = self.pointset[i][0]  # Current x value
            group = []  # Store group of y-values for the same x

            # Collect all points with the same x
            while i < self.pointset_length and self.pointset[i][0] == x_val:
                group.append(self.pointset[i][1])
                i += 1  # Move to the next point

            # Generate permutations
            for _ in range(self.number_of_permutations):
                shuffled_group = group[:]  # Copy the y values
                random.shuffle(shuffled_group)  # Shuffle in-place

                # Reconstruct the permuted pointset
                if len(permutations) < self.number_of_permutations:
                    permutations.append([])  # Initialize list

                permutations[_].extend([[x_val, y] for y in shuffled_group])

        return permutations

    def value_deviance(self) -> None:
        star_discrepancy_values = []
        permutated_pointsets = self.permute_original_pointset()
        
        for i in range(len(permutated_pointsets)):
            star_discrepancy_values.append(Bundschuh_Zhu_Algorithm_TP2(permutated_pointsets[i]))
        
        # I want to get rid of this line
        print(Counter(star_discrepancy_values))

    def show_permutations(self) -> None:
        permuted_pointsets = self.permute_original_pointset()
        
        print("Original Sorted Pointset:")
        show_pointset(self.pointset)
        print(f"Star discrepancy: {Bundschuh_Zhu_Algorithm_TP2(self.pointset)}")

        print("\nPermuted Pointsets:\n")
        for i, permuted in enumerate(permuted_pointsets, 1):
            print(f"Permutation {i}:")
            show_pointset(permuted)
            print(f"Star discrepancy: {Bundschuh_Zhu_Algorithm_TP2(permuted)}")

class DoubleValuePointset:
    def __init__(self, pointset_length : int = 10, decimal_places : int = 1):
        self.pointset_length = pointset_length
        self.decimal_places = decimal_places 
        self.main_pointset = self.generate_main_pointset()
        self.switched_pointset = self.generate_swapped_pointset()
        
    def generate_main_pointset(self) -> list:
        points_x = []
        points_y = []
        
        for _ in range(self.pointset_length // 2):
            # X value is appended twice and 2 y values are generated 
            x = round(random.uniform(0,1), self.decimal_places)
            y_1 = round(random.uniform(0,1), self.decimal_places)
            points_x.append(x)
            points_y.append(y_1)
            
            y_2 = round(random.uniform(0,1), self.decimal_places)
            points_x.append(x)
            points_y.append(y_2)
        
        return sorted([list(coordinate) for coordinate in zip(points_x, points_y)], key=lambda coord : coord[0])
        
    def generate_swapped_pointset(self) -> list:
        # deepcopy() is needed otherwise it will be saved in memory as the same variable
        switched_pointset = copy.deepcopy(self.main_pointset)
        
        for i in range(0, len(switched_pointset) - 1, 2):
            switched_pointset[i][1], switched_pointset[i+1][1] = switched_pointset[i+1][1], switched_pointset[i][1]
            
        return switched_pointset
        
if __name__ == "__main__":
    pointset_class = DoubleValuePointset()
    print(Bundschuh_Zhu_Algorithm_TP2(pointset_class.main_pointset))
    print(Bundschuh_Zhu_Algorithm_TP2(pointset_class.switched_pointset))