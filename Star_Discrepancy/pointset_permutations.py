import random
from collections import Counter
from Bundschuh_Zhu_Algorithm import Bundschuh_Zhu_Algorithm_TP2

def show_pointset(pointset : list) -> None:
    for i in range(len(pointset)):
        print(f"{pointset[i]}")

def generate_pointset(n : int, repeating_probability : float = 0, decimal_places : int = 8) -> list:
    # Code in this is ugly as shit but it works
    # Repeating probability should be between 0 and 1
    points_x = []
    points_y = []
    for i in range(n):
        # Uniform instead of randint since it returns floats instead of ints
        x = round(random.uniform(0,1), decimal_places)
        y = round(random.uniform(0,1), decimal_places)
        # Chooses a random value between 1,100 (1% - 100%) and checks whether its larger than the probability * 100
        if(random.randint(1,100) <= int(repeating_probability*100) and i != 0):
            # True for x coordinate, False for y coordinate
            if(random.choice([True, False])):
                x = random.choice(points_x)
            else:
                y = random.choice(points_y)

        points_x.append(x)
        points_y.append(y)
    
    return sorted([list(coordinate) for coordinate in zip(points_x, points_y)], key=lambda coord : coord[0])

def permute_original_pointset(pointset, num_permutations=1):
    # Function generated by ChatGPT that just works
    permutations = []
    # Process the sorted pointset in one pass
    i = 0
    n = len(pointset)
    while i < n:
        x_val = pointset[i][0]  # Current x value
        group = []  # Store group of y-values for the same x
        
        # Collect all points with the same x
        while i < n and pointset[i][0] == x_val:
            group.append(pointset[i][1])
            i += 1  # Move to the next point
        
        # Generate permutations
        for _ in range(num_permutations):
            shuffled_group = group[:]  # Copy the y values
            random.shuffle(shuffled_group)  # Shuffle in-place
            
            # Reconstruct the permuted pointset
            if len(permutations) < num_permutations:
                permutations.append([])  # Initialize list
            
            permutations[_].extend([[x_val, y] for y in shuffled_group])
    
    return permutations

def value_deviance(pointset : list, num_permutations : int):
    star_discrepancy_values = []
    permutated_pointsets = permute_original_pointset(pointset, num_permutations)
    for i in range(len(permutated_pointsets)):
        star_discrepancy_values.append(Bundschuh_Zhu_Algorithm_TP2(permutated_pointsets[i]))

    print(Counter(star_discrepancy_values))

def show_permutations(pointset : list, num_permutations : int) -> None:
    # Create permutations
    permuted_pointsets = permute_original_pointset(pointset, num_permutations)
    # Print results
    print("Original Sorted Pointset:")
    show_pointset(pointset)
    print(f"Star discrepancy: {Bundschuh_Zhu_Algorithm_TP2(pointset)}")
    # Print out permutations
    print("\nPermuted Pointsets:")
    for i, permuted in enumerate(permuted_pointsets, 1):
        print(f"Permutation {i}:")
        show_pointset(permuted)
        print(f"Star discrepancy: {Bundschuh_Zhu_Algorithm_TP2(permuted)}")

if __name__ == "__main__":
    # Main paramters for generating the pointset
    N = 10 # Pointset size
    R = 0.6 # Repeating probability
    D = 1 # Decimal places
    P = 3 # Permutations
    # Simply which you want to see
    display_points = True
    # Generates original pointset
    pointset = generate_pointset(n = N, repeating_probability=R, decimal_places=D)
    if(display_points):
        # Display all pointsets
        star_discrepancy = Bundschuh_Zhu_Algorithm_TP2(pointset)
        show_permutations(pointset, P)
    else:
        # Just focus on D* values
        value_deviance(pointset, P)